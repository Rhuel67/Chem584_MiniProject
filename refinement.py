import miniproj as mp
import numpy as np
import matplotlib.pyplot as plt

# constants:
om_e = 1.76361347017282E-02 # omega_e in atomic units
mu = 1728.25675893 # reduced mass in atomic units

dcSdf = 1/(2*mu*om_e)
dcAdf = 1/(2*mu*om_e)

dcSdg = -mu*om_e/2
dcAdg = mu*om_e/2

def update_basis_energies(om_e:float, om_x:float, 
                          basis: tuple[list[tuple[int, int]], list[tuple[int, int]], list[float]]):
    '''
    Updates the independent Morse oscillator basis state energies in 'basis' in place.

    :param om_e: new oscillator frequency omega_e
    :param om_x: new correction frequency omega_x
    :param basis: the basis tuple to be updated
    '''
    for n in range(0,len(basis[2])):
        basis[2][n] = mp.get_e_n(om_e, om_x, n)

def construct_unique_label(label:tuple[int,int,int], nmax:int) -> int:
    '''
    Generates a unique index for the state with label (n1, n2, s).

    :param label: label of the form (n1, n2, s)
    :param nmax: maximum value allowed for n1 or n2
    '''
    return label[2] * (label[0]*nmax + label[1])

def add_unique_label_dict(res: list[dict], nmax: int):
    '''
    Adds the label generated by construct_unique_label to each dict in list 'res' in place.

    :param res: list of dicts containing calculation result data
    :param nmax: maximum value allowed for n1 or n2
    '''
    for s in res:
        s['unique'] = construct_unique_label((s['n1'], s['n2'], 1 if s['s']=='+' else -1), nmax)

def get_calc_exp_pairs(calcs: list[dict], exps: list[tuple]):
    '''
    Matches states in the result of a calcuation with those of experiment based on their unique 
    labels. Zips matched states into a list of tuples of the form (calc, exp).

    :param res: list of dicts containing calculation result data
    :param exps: list of tuples of the form (unique label, transition energy)
    '''
    pairs = []
    for exp in exps:
        for calc in calcs:
            if exp[0] == calc['unique']:
                pairs.append((calc, exp))
                break
    return pairs

def weight(n1:int, n2:int) -> float:
    '''
    The weight function to be used in the calculation of cost.
    '''
    return 1


def cost(pairs: list[tuple]) -> float:
    '''
    Calculates the cost function (sum of weighted, squared residuals) from a list of paried calculation 
    and experimental states.

    :param pairs: list of tuples of paired states of the form (calc, exp)
    '''
    chi_sq = float(0)
    for pair in pairs:
        w = weight(pair[0]['n1'],pair[0]['n2'])
        chi_sq += w*(pair[0]['Et'] - pair[1][1])**2
    return chi_sq/2

def unweighted_cost(pairs: list[tuple]) -> float:
    '''
    Calculates the unweighted cost function (sum of squared residuals) from a list of paried calculation 
    and experimental states. This function is not the objective of the minimization, but is used to track
    the status of the optimization. 

    :param pairs: list of tuples of paired states of the form (calc, exp)
    '''
    chi_sq = float(0)
    for pair in pairs:
        chi_sq += (pair[0]['Et'] - pair[1][1])**2
    return chi_sq/2

def grad_cost_single_basis(pairs: list[tuple], gradH2D: np.ndarray):
    '''
    Calculates the contribution of a single basis (+ or -) to the total gradient of the cost function from 
    the gradients of matrix elements of H2D in that basis.

    :param pairs: list of tuples of paired states of the form (calc, exp)
    :param gradH2D: gradient of H2D, [dH2D/dDe, dH2D/df, dH2D/dg]
    '''
    grad_cost = np.array([0, 0, 0], float)
    for i in pairs:
        evec = np.array(i[0]['vector'])
        res = i[0]['Et']-i[1][1]
        w = weight(i[0]['n1'],i[0]['n2'])
        gradE = np.dot(np.matmul(gradH2D, evec), evec)
        grad_cost += w*res*gradE
    return grad_cost


def dH0dDe(basis: tuple[list[tuple[int, int]], list[tuple[int, int]], list[float]], sym: int, v: np.ndarray):
    '''
    Returns a list of partial derivatives dH0/dDe for each state in 'basis'.

    :param basis: list of states to calculate partial derivative for
    :param sym: symmetry of basis
    :param v: current values of the parameters to minimize over (v[0] = De)
    '''
    n1n2s = basis[0] if sym == 1 else basis[1]
    dH0dDe = []
    for Nt in n1n2s:
        dH0dDe.append(om_e**2/(4*v[0]**2) * ((Nt[0]+1/2)**2 + (Nt[1]+1/2)**2))
    return dH0dDe


def grad_cost(pairs: list[tuple], basis: tuple[list[tuple[int, int]], list[tuple[int, int]], list[float]], 
              S: tuple[np.ndarray,np.ndarray], A: tuple[np.ndarray,np.ndarray]) -> np.ndarray:
    '''
    Calculates the total gradient of the cost function across a combined basis.

    :param pairs: list of tuples of paired states of the form (calc, exp)
    :param basis: combined basis of the form (+basis, -basis)
    :param S: tuple of A matricies in each basis (A_s, A_a)
    :param A: tuple of S matricies in each basis (S_s, S_a)
    '''
    pairs_s = list(filter(lambda p: p[1][0]>=0, pairs))
    pairs_a = list(filter(lambda p: p[1][0]<0, pairs))

    n1n2s_s = basis[0] # symmetric combined basis state labels, list of tuples (n1,n2) 
    n1n2s_a = basis[1] # antisymmetric combinded basis state labels, list of tuples (n1,n2)

    N_size_s = len(n1n2s_s) # number of symmetric basis states
    N_size_a = len(n1n2s_a) # number of antisymmetric basis states

    dH0_s = np.zeros((N_size_s,N_size_s)) # matrix dH0/dDe for symmetric basis states
    dH0_a = np.zeros((N_size_a,N_size_a)) # matrix dH0/dDe for antisymmetric basis states

    dH0_s_l = dH0dDe(basis, 1, v) # list of partial derivatives of H0 w/r to De for each symmetric basis state 
    dH0_a_l = dH0dDe(basis, -1, v) # list of partial derivatives of H0 w/r to De for each antisymmetric basis state 

    # filling diagonal elements of dH0/dDe matricies
    np.fill_diagonal(dH0_s, dH0_s_l)
    np.fill_diagonal(dH0_a, dH0_a_l)

    S_s = S[0]
    S_a = S[1]

    A_s = A[0]
    A_a = A[1]

    dH1df_s = dcSdf*S_s + dcAdf*A_s # matrix dH1/df for symmetric basis states
    dH1df_a = dcSdf*S_a + dcAdf*A_a # matrix dH1/df for antisymmetric basis states

    dH1dg_s = dcSdg*S_s + dcAdg*A_s # matrix dH1/dg for symmetric basis states
    dH1dg_a = dcSdg*S_a + dcAdg*A_a # matrix dH1/dg for antisymmetric basis states

    gradH2D_s = np.array([dH0_s, dH1df_s, dH1dg_s]) # gradient of H2D in the symmetric basis
    gradH2D_a = np.array([dH0_a, dH1df_a, dH1dg_a]) # gradient of H2D in the antisymmetric basis

    grad_cost_s = grad_cost_single_basis(pairs_s, gradH2D_s) # contribution of symmetric states to gradient of cost
    grad_cost_a = grad_cost_single_basis(pairs_a, gradH2D_a) # contribution of antisymmetric states to gradient of cost

    return grad_cost_s + grad_cost_a
    
'''
Used to implement scipy.optimize.minimize(method='BFGS'). Not used in final version.

def objective(x, *args):
    (om_e, exp_s_e, basis, (S, A), mu) = args
    v = x
    
    om_x = om_e**2/(4*v[0])
    update_basis_energies(om_e, om_x, basis)
    c_S = v[1]/(2*mu*om_e) - v[2]*mu*om_e/2 # c_S in atomic units
    c_A = v[1]/(2*mu*om_e) + v[2]*mu*om_e/2 # c_a in atomic units
    
    calc_states = mp.find_vib_levels_fixed_basis(c_S, c_A, basis, S, A)
    add_unique_label_dict(calc_states, max(exp_n1s))

    pairs = get_calc_exp_pairs(calc_states, exp_s_e)
    print(len(pairs))

    cost_n = cost(pairs)
    print(cost_n)
    grad_n = grad_cost(pairs, basis, S, A)

    return (cost_n, grad_n)'''


if __name__=="__main__":
    exp_n1s = [1,1,2,2,1,3,3,2,2,4,4,3,3,2,5,5,4,4,3,6,6,5,5,7,7,8]
    exp_n2s = [0,0,0,0,1,0,0,1,1,0,0,1,1,2,0,0,1,1,2,0,0,1,1,0,0,0]
    exp_s = [1,-1,1,-1,1,1,-1,1,-1,1,-1,1,-1,1,1,-1,1,-1,1,1,-1,1,-1,1,-1,-1]
    exp_trans_es_cm = [3657.053,3755.929,7201.54,7249.818,7445.045,10599.686,10613.355,10868.876,11032.406,13828.277,13830.938,14221.161,14318.812,14537.504,16898.4,16898.842,17458.354,17495.528,17748.11,19781,19781.105,20533.6,20543.137,22529.296,22529.441,25120.278]
    exp_trans_es = [mp.tohart(e) for e in exp_trans_es_cm]

    exp_states = [construct_unique_label(label,max(exp_n1s)) for label in zip(exp_n1s,exp_n2s,exp_s)]
    exp_s_e = list(zip(exp_states, exp_trans_es))

    # values to refine:
    De = 2.09125209448514E-01
    f = -5.63113857298E-03
    g = -8.66321545161E-06

    # gradient descent parameters
    d = 0.0001 # step size
    n = 100 # number of steps

    v = np.array([De, f, g])

    om_x = om_e**2/(4*v[0]) # omega_x in atomic units

    basis = mp.generate_basis_from_maxn(om_e,om_x,max(exp_n1s))

    (S, A) = mp.calc_SA(basis)

    args = (om_e, exp_s_e, basis, (S, A), mu)

    #res = opt.minimize(objective, v, args, method='BFGS', jac=True, options={'disp': True})
    #v = res.x
    
    
    c_S = v[1]/(2*mu*om_e) - v[2]*mu*om_e/2 # c_S in atomic units
    c_A = v[1]/(2*mu*om_e) + v[2]*mu*om_e/2 # c_a in atomic units
    
    calc_states = mp.find_vib_levels_fixed_basis(c_S, c_A, basis, S, A)
    add_unique_label_dict(calc_states, max(exp_n1s))

    pairs = get_calc_exp_pairs(calc_states, exp_s_e)
    pairs_initial = pairs

    cost_initial = cost(pairs)
    grad_cost_initial = grad_cost(pairs, basis, S, A)
    n_grad_init = np.linalg.norm(grad_cost_initial)

    unweighted_cost_initial = unweighted_cost(pairs)
    
    print("Initial Configuration:")
    print(f"D_e = {v[0]}")
    print(f"f = {v[1]}")
    print(f"g = {v[2]}")
    print(f"cost: {cost_initial}")
    print(f"gradient: {grad_cost_initial}")
    print()
    
    # cost and gradient of current iteration
    cost_i = cost_initial
    grad_i = grad_cost_initial

    for i in range(1, n+1):
        # store cost and gradient from prior iteration
        cost_imin1 = cost_i
        grad_imin1 = grad_i

        print(f"Starting iteration {i}")
        # update v
        v = v - d * grad_i

        # update dependencies
        om_x = om_e**2/(4*v[0])
        c_S = v[1]/(2*mu*om_e) - v[2]*mu*om_e/2 
        c_A = v[1]/(2*mu*om_e) + v[2]*mu*om_e/2 
        update_basis_energies(om_e, om_x, basis)

        # perform calculation
        print(f"Performing calculation with")
        print(f"D_e = {v[0]}")
        print(f"f = {v[1]}")
        print(f"g = {v[2]}")
        calc_states = mp.find_vib_levels_fixed_basis(c_S, c_A, basis, S, A)
        
        # calculate new cost and gradient
        add_unique_label_dict(calc_states, max(exp_n1s))
        pairs = get_calc_exp_pairs(calc_states, exp_s_e)
        
        cost_i = cost(pairs)
        grad_i = grad_cost(pairs, basis, S, A)

        del_cost = cost_i - cost_imin1
        del_grad = grad_i - grad_imin1

        print()
        print(f"cost: {cost_i}")
        print(f"{'up  ' if del_cost>0 else 'down'} {abs(del_cost)} compared to iteration {i-1}")
        print(f"gradient: {grad_i}")
        print(f"change in gradient from this iteration: {del_grad}")
        print(f"Current cost is {(cost_i/cost_initial*100):.3f}% of initial")
        print(f"Current unweighted cost is {(unweighted_cost(pairs)/unweighted_cost_initial*100):.3f}% of initial")
        print(f"Current |gradient| is {(np.linalg.norm(grad_i)/n_grad_init*100):.3f}% of initial")
        print()
        print()

    # Summarize change in eigenvalues from optimization
    for i, p in enumerate(pairs):
        print(f"({p[0]['n1']},{p[0]['n2']},{p[0]['s']}):"+ 
              f"{mp.toinvcm(pairs_initial[i][0]['Et']):8.2f} -> "+
              f"{mp.toinvcm(p[0]['Et']):8.2f} "+
              f"vs {mp.toinvcm(p[1][1]):8.2f}"+
              f"   Residual: {mp.toinvcm(pairs_initial[i][0]['Et']-pairs_initial[i][1][1]):8.2f} -> "+
              f"{mp.toinvcm(p[0]['Et']-p[1][1]):8.2f}"+
              f"    Delta r^2: {-mp.toinvcm(pairs_initial[i][0]['Et']-pairs_initial[i][1][1])**2+mp.toinvcm(p[0]['Et']-p[1][1])**2:8.2f}"+
              f"")
    
    print()
    print(f"Final Parameters")
    print(f"D_e = {v[0]}")
    print(f"f = {v[1]}")
    print(f"g = {v[2]}")

    print()
    print(f"Cost was reduced by {((1-cost_i/cost_initial)*100):.3f}%")
    print(f"|gradient| was reduced by {((1-np.linalg.norm(grad_i)/n_grad_init)*100):.3f}%")

    
    for i, p in enumerate(pairs):
        print(f"({p[0]['n1']},{p[0]['n2']},{p[0]['s']})"+ 
              f"&{mp.toinvcm(p[0]['Et']):8.2f}"+
              f"&{mp.toinvcm(p[1][1]):8.2f}"+
              f"&{(abs(mp.toinvcm(p[0]['Et'])-mp.toinvcm(p[1][1]))/mp.toinvcm(p[1][1])*100):5.3f}\\%\\\\")

    '''
    # Plotting
    fig, ax = plt.subplots(figsize=(15,9), dpi=72)

    ntot_mins = [0]*(max(exp_n1s)+1)
    ans = []

    w = 0.2
    bbox_args = dict(boxstyle="round",alpha=0)
    arrow_args = dict(facecolor='black', arrowstyle="-")
    for i in zip(exp_n1s, exp_n2s, exp_trans_es_cm, exp_s):
        ntot = i[0] + i[1]

        if(ntot_mins[ntot] == 0): ntot_mins[ntot] = i[2]

        x = [ntot-w, ntot+w]
        y = [i[2]-ntot_mins[ntot]]*2
        ax.plot(x, y, color="tab:blue")

        tx = ntot-w-0.3
        ty = i[2]-ntot_mins[ntot]
        label = f"({i[0]} {i[1]},{'+' if i[3]==1 else r'$-$'})"
        ans.append(ax.annotate(label, (x[0],y[0]), xytext=(tx,ty), arrowprops=arrow_args, bbox=bbox_args))

    for i in pairs_initial:
        ntot = i[0]['n1'] + i[0]['n2']
        x = [ntot-w, ntot+w]
        y = [mp.toinvcm(i[0]['Et'])-ntot_mins[ntot]]*2
        ax.plot(x, y, color="tab:orange")

        tx = ntot+w
        ty = mp.toinvcm(i[0]['Et'])-ntot_mins[ntot]
        label = f"({i[0]['n1']} {i[0]['n2']},{'+' if i[0]['s']=='+' else r'$-$'})"
        ans.append(ax.annotate(label, (x[1],y[0]), xytext=(tx,ty), arrowprops=arrow_args, bbox=bbox_args))
    
    for an in ans:
        an.draggable()

    plt.show()
    '''
    

    